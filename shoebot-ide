#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-

import pygtk
pygtk.require('2.0')
import sys, os, errno
import gobject
import gtk
import pango
import gtksourceview

# only necessary for ShoebotError
import shoebot

RESPONSE_FORWARD = 0
RESPONSE_BACKWARD = 1

ICON_FILE = '/usr/share/pixmaps/shoebot-ide.png'

def hsv_to_rgb(h, s, v):
    if s == 0.0:
        return (v, v, v)
    else:
        hue = h * 6.0
        saturation = s
        value = v

        if hue >= 6.0:
            hue = 0.0

        f = hue - int(hue)
        p = value * (1.0 - saturation)
        q = value * (1.0 - saturation * f)
        t = value * (1.0 - saturation * (1.0 - f))

        ihue = int(hue)
        if ihue == 0:
            return(value, t, p)
        elif ihue == 1:
                return(q, value, p)
        elif ihue == 2:
                return(p, value, t)
        elif ihue == 3:
            return(p, q, value)
        elif ihue == 4:
            return(t, p, value)
        elif ihue == 5:
            return(value, p, q)

def hue_to_color(hue):
    if hue > 1.0:
        raise ValueError

    h, s, v = hsv_to_rgb (hue, 1.0, 1.0)
    return (h*65535, s*65535, v*65535)


class Buffer(gtksourceview.SourceBuffer):
    N_COLORS = 16
    PANGO_SCALE = 1024

    def __init__(self):
        gtk.TextBuffer.__init__(self)
        tt = self.get_tag_table()
        self.refcount = 0
        self.filename = None
        self.untitled_serial = -1
        self.color_tags = []
        self.color_cycle_timeout_id = 0
        self.start_hue = 0.0

        for i in range(Buffer.N_COLORS):
            tag = self.create_tag()
            self.color_tags.append(tag)

        #self.invisible_tag = self.create_tag(None, invisible=True)
        self.not_editable_tag = self.create_tag(editable=False,
                                                foreground="purple")
        self.found_text_tag = self.create_tag(foreground="red")

        tabs = pango.TabArray(4, True)
        tabs.set_tab(0, pango.TAB_LEFT, 10)
        tabs.set_tab(1, pango.TAB_LEFT, 30)
        tabs.set_tab(2, pango.TAB_LEFT, 60)
        tabs.set_tab(3, pango.TAB_LEFT, 120)
        self.custom_tabs_tag = self.create_tag(tabs=tabs, foreground="green")
        TestText.buffers.push(self)

    def pretty_name(self):
        if self.filename:
            return os.path.basename(self.filename)
        else:
            if self.untitled_serial == -1:
                self.untitled_serial = TestText.untitled_serial
                TestText.untitled_serial += 1

            if self.untitled_serial == 1:
                return "Untitled"
            else:
                return "Untitled #%d" % self.untitled_serial

    def filename_set(self):
        for view in TestText.views:
            if view.text_view.get_buffer() == self:
                view.set_view_title()

    def search(self, str, view, forward):
        # remove tag from whole buffer
        start, end = self.get_bounds()
        self.remove_tag(self.found_text_tag, start, end)

        iter = self.get_iter_at_mark(self.get_insert())

        i = 0
        if str:
            if forward:
                while 1:
                    res = iter.forward_search(str, gtk.TEXT_SEARCH_TEXT_ONLY)
                    if not res:
                        break
                    match_start, match_end = res
                    i += 1
                    self.apply_tag(self.found_text_tag, match_start, match_end)
                    iter = match_end
            else:
                while 1:
                    res = iter.backward_search(str, gtk.TEXT_SEARCH_TEXT_ONLY)
                    if not res:
                        break
                    match_start, match_end = res
                    i += 1
                    self.apply_tag(self.found_text_tag, match_start, match_end)
                    iter = match_start

        dialog = gtk.MessageDialog(view,
                                   gtk.DIALOG_DESTROY_WITH_PARENT,
                                   gtk.MESSAGE_INFO,
                                   gtk.BUTTONS_OK,
                                   "%d strings found and marked in red" % i)

        dialog.connect("response", lambda x,y: dialog.destroy())

        dialog.show()

    def search_forward(self, str, view):
        self.search(str, view, True)

    def search_backward(self, str, view):
        self.search(str, view, False)

    def ref(self):
        self.refcount += 1

    def unref(self):
        self.refcount -= 1
        if self.refcount == 0:
            self.set_colors(False)
            TestText.buffers.remove(self)
            del self

    def color_cycle_timeout(self):
        self.cycle_colors()
        return True

    def set_colors(self, enabled):
        hue = 0.0

        if (enabled and self.color_cycle_timeout_id == 0):
            self.color_cycle_timeout_id = gtk.timeout_add(
                200, self.color_cycle_timeout)
        elif (not enabled and self.color_cycle_timeout_id != 0):
            gtk.timeout_remove(self.color_cycle_timeout_id)
            self.color_cycle_timeout_id = 0

        for tag in self.color_tags:
            if enabled:
                color = apply(TestText.colormap.alloc_color,
                              hue_to_color(hue))
                tag.set_property("foreground_gdk", color)
            else:
                tag.set_property("foreground_set", False)
            hue += 1.0 / Buffer.N_COLORS

    def cycle_colors(self):
        hue = self.start_hue

        for tag in self.color_tags:
            color = apply(TestText.colormap.alloc_color,
                          hue_to_color (hue))
            tag.set_property("foreground_gdk", color)

            hue += 1.0 / Buffer.N_COLORS
            if hue > 1.0:
                hue = 0.0

        self.start_hue += 1.0 / Buffer.N_COLORS
        if self.start_hue > 1.0:
            self.start_hue = 0.0

    def tag_event_handler(self, tag, widget, event, iter):
        char_index = iter.get_offset()
        tag_name = tag.get_property("name")
        if event.type == gtk.gdk.MOTION_NOTIFY:
            print "Motion event at char %d tag `%s'\n" % (char_index, tag_name)
        elif event.type == gtk.gdk.BUTTON_PRESS:
            print "Button press at char %d tag `%s'\n" % (char_index, tag_name)
        elif event.type == gtk.gdk._2BUTTON_PRESS:
            print "Double click at char %d tag `%s'\n" % (char_index, tag_name)
        elif event.type == gtk.gdk._3BUTTON_PRESS:
            print "Triple click at char %d tag `%s'\n" % (char_index, tag_name)
        elif event.type == gtk.gdk.BUTTON_RELEASE:
            print "Button release at char %d tag `%s'\n" % (char_index, tag_name)
        elif (event.type == gtk.gdk.KEY_PRESS or
              event.type == gtk.gdk.KEY_RELEASE):
            print "Key event at char %d tag `%s'\n" % (char_index, tag_name)
        return False

    def fill_file_buffer(self, filename):
        try:
            f = open(filename, "r")
        except IOError, (errnum, errmsg):
            err = "Cannot open file '%s': %s" % (filename, errmsg)
            view = TestText.active_window_stack.get()
            dialog = gtk.MessageDialog(view, gtk.DIALOG_MODAL,
                                       gtk.MESSAGE_INFO,
                                       gtk.BUTTONS_OK, err);
            result = dialog.run()
            dialog.destroy()
            return False

        iter = self.get_iter_at_offset(0)
        buf = f.read()
        f.close()
        self.set_text(buf)
        self.set_modified(False)

        return True

    def save_buffer(self):
        result = False
        have_backup = False
        if not self.filename:
            return False

        bak_filename = self.filename + "~"
        try:
            os.rename(self.filename, bak_filename)
        except (OSError, IOError), (errnum, errmsg):
            if errnum != errno.ENOENT:
                err = "Cannot back up '%s' to '%s': %s" % (self.filename,
                                                           bak_filename,
                                                           errmsg)
                view = TestText.active_window_stack.get()
                dialog = gtk.MessageDialog(view, gtk.DIALOG_MODAL,
                                           gtk.MESSAGE_INFO,
                                           gtk.BUTTONS_OK, err);
                dialog.run()
                dialog.destroy()
                return False

        have_backup = True
        start, end = self.get_bounds()
        chars = self.get_slice(start, end, False)
        try:
            file = open(self.filename, "w")
            file.write(chars)
            file.close()
            result = True
            self.set_modified(False)
        except IOError, (errnum, errmsg):
            err = "Error writing to '%s': %s" % (self.filename, errmsg)
            view = TestText.active_window_stack.get()
            dialog = gtk.MessageDialog(view, gtk.DIALOG_MODAL,
                                       gtk.MESSAGE_INFO,
                                       gtk.BUTTONS_OK, err);
            dialog.run()
            dialog.destroy()

        if not result and have_backup:
            try:
                os.rename(bak_filename, self.filename)
            except OSError, (errnum, errmsg):
                err = "Can't restore backup file '%s' to '%s': %s\nBackup left as '%s'" % (
                    self.filename, bak_filename, errmsg, bak_filename)
                view = TestText.active_window_stack.get()
                dialog = gtk.MessageDialog(view, gtk.DIALOG_MODAL,
                                           gtk.MESSAGE_INFO,
                                           gtk.BUTTONS_OK, err);
                dialog.run()
                dialog.destroy()

        return result

    def confirm_overwrite_callback(self, chooser):
      uri = chooser.get_uri()
      if os.path.exists(self.filename):
          if os.path.exists(self.filename):
              if user_wants_to_replace_read_only_file (uri):
                  return gtk.FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME
              else:
                  return gtk.FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN
          else:
              # fall back to the default dialog
              return gtk.FILE_CHOOSER_CONFIRMATION_CONFIRM

    def save_as_buffer(self):
        chooser = ShoebotFileChooserDialog('Save File', None, gtk.FILE_CHOOSER_ACTION_SAVE,
            (gtk.STOCK_SAVE, gtk.RESPONSE_ACCEPT,
             gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL))
        chooser.set_do_overwrite_confirmation(True)

        chooser.connect("confirm-overwrite", self.confirm_overwrite_callback)

	if chooser.run() == gtk.RESPONSE_ACCEPT:
            old_filename = self.filename
            self.filename = chooser.get_filename()
            if self.save_buffer():
                self.filename = chooser.get_filename()
                self.filename_set()
            else:
		self.filename = old_filename
        chooser.destroy()

    def check_buffer_saved(self):
        if self.get_modified():
            pretty_name = self.pretty_name()
            msg = "Save changes to '%s'?" % pretty_name
            view = TestText.active_window_stack.get()
            dialog = gtk.MessageDialog(view, gtk.DIALOG_MODAL,
                                       gtk.MESSAGE_QUESTION,
                                       gtk.BUTTONS_YES_NO, msg);
            dialog.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
            result = dialog.run()
            dialog.destroy()
            if result == gtk.RESPONSE_ACCEPT:
                if self.filename:
                    return self.save_buffer()
                return self.save_as_buffer()
            elif result == gtk.RESPONSE_CANCEL:
                return False
            else:
                return True
        else:
            return True


class ShoebotFileChooserDialog (gtk.FileChooserDialog):

	CWD = None

	def __init__ (self, *args, **kwargs):
		super (ShoebotFileChooserDialog, self).__init__ (*args, **kwargs)

		# set some defaults
		self.set_default_response (gtk.RESPONSE_OK)
		self.set_property ('do-overwrite-confirmation', True)

		# set the working directory if available
		if ShoebotFileChooserDialog.CWD is not None:
			self.set_current_folder (ShoebotFileChooserDialog.CWD)

	def run (self):
		response = super (ShoebotFileChooserDialog, self).run ()

		# get the working directory if the user clicked accepted the action
		if response == gtk.RESPONSE_ACCEPT:
			ShoebotFileChooserDialog.CWD = self.get_current_folder ()

		return response




class View(gtk.Window):
    gobject.type_register (ShoebotFileChooserDialog)

    def __init__(self, buffer=None):
        menu_items = [
            ( "/_File", None, None, 0, "<Branch>" ),
            ( "/File/_New", "<control>N", self.do_new, 0, None ),
            ( "/File/_Open", "<control>O", self.do_open, 0, None ),
            ( "/File/_Save", "<control>S", self.do_save, 0, None ),
            ( "/File/Save _As...", None, self.do_save_as, 0, None ),
            ( "/File/sep1", None, None, 0, "<Separator>" ),
            ( "/File/_Close", "<control>W" , self.do_close, 0, None ),
            ( "/File/E_xit", "<control>Q" , self.do_exit, 0, None ),
            ( "/_Edit", None, None, 0, "<Branch>" ),
            ( "/Edit/Undo", "<control>Z", self.do_undo, 0, None ),
            ( "/Edit/Redo", "<control><shift>Z", self.do_redo, 0, None ),
            ( "/Edit/sep1", None, None, 0, "<Separator>" ),
            ( "/Edit/Find...", "<control>F", self.do_search, 0, None ),
            ( "/_Settings", None, None, 0, "<Branch>" ),
            ( "/Settings/Wrap _Off", None, self.do_wrap_changed, gtk.WRAP_NONE, "<RadioItem>" ),
            ( "/Settings/Wrap _Words", None, self.do_wrap_changed, gtk.WRAP_WORD, "/Settings/Wrap Off" ),
            ( "/Settings/Wrap _Chars", None, self.do_wrap_changed, gtk.WRAP_CHAR, "/Settings/Wrap Off" ),
            ( "/_Run", None, None, 0, "<Branch>" ),
            ( "/Run/_Run script", "<control>R", self.run_script, False, None ),
            ( "/Run/sep1", None, None, 0, "<Separator>" ),
            ( "/Run/Run socket server", None, self.do_socketserver_changed, True, "<ToggleItem>"),
            ( "/Run/Show variables window", None, self.do_varwindow_changed, True, "<ToggleItem>")
            ]

        if not buffer:
            buffer = Buffer()
        gtk.Window.__init__(self)

        TestText.views.push(self)

        buffer.ref()

        if not TestText.colormap:
            TestText.colormap = self.get_colormap()

        self.connect("delete_event", self.delete_event_cb)

        self.accel_group = gtk.AccelGroup()
        self.item_factory = gtk.ItemFactory(gtk.MenuBar, "<main>",
                                        self.accel_group)
        self.item_factory.set_data("view", self)
        self.item_factory.create_items(menu_items)

        self.add_accel_group(self.accel_group)

        vbox = gtk.VBox(False, 0)
        self.add(vbox)

        vbox.pack_start(self.item_factory.get_widget("<main>"),
                        False, False, 0)

        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

        self.text_view = gtksourceview.SourceView(buffer)
        self.text_view.set_wrap_mode(gtk.WRAP_WORD)
        self.text_view.set_show_line_numbers(True)
        self.text_view.set_auto_indent(True)
        self.text_view.set_insert_spaces_instead_of_tabs(True)
        # FIXME: the following 2 lines don't have any effect :/
        self.text_view.tab_width = 4
        self.text_view.indent_width = 4
        self.text_view.connect("expose_event", self.tab_stops_expose)

        self.bhid = buffer.connect("mark_set", self.cursor_set_callback)

        self.text_view.modify_font(pango.FontDescription('Bitstream Vera Sans Mono 8'))

        vbox.pack_start(sw, True, True, 0)
        sw.add(self.text_view)

        self.set_default_size(500, 500)
        self.text_view.grab_focus()

        self.set_view_title()
        self.init_menus()

        # options toggle
        self.use_varwindow = False
        self.use_socketserver = False

        # setup syntax highlighting
        manager = gtksourceview.SourceLanguagesManager()
        language = manager.get_language_from_mime_type("text/x-python")
        buffer.set_language(language)
        buffer.set_highlight(True)


        try:
            self.set_icon_from_file(ICON_FILE)
        except gobject.GError:
            # icon not found = no icon
            pass

        self.show_all()

    def delete_event_cb(self, window, event, data=None):
        TestText.active_window_stack.push(self)
        self.check_close_view()
        TestText.active_window_stack.pop()
        return True
    #
    # Menu callbacks
    #
    def get_empty_view(self):
        buffer = self.text_view.get_buffer()
        if (not buffer.filename and not buffer.get_modified()):
            return self
        else:
            return View(Buffer())

    def view_from_widget(widget):
        if isinstance(widget, gtk.MenuItem):
            item_factory = gtk.item_factory_from_widget(widget)
            return item_factory.get_data("view")
        else:
            app = widget.get_toplevel()
            return app.get_data("view")

    def do_new(self, callback_action, widget):
        View()

    def open_ok_func(self, filename):
        new_view = self.get_empty_view()
        buffer = new_view.text_view.get_buffer()
        if not buffer.fill_file_buffer(filename):
            if new_view != self:
                new_view.close_view()
            return False
        else:
            buffer.filename = filename
            buffer.filename_set()
            return True

    def do_open(self, callback_action, widget):
        chooser = ShoebotFileChooserDialog('Open File', None, gtk.FILE_CHOOSER_ACTION_OPEN,
            (gtk.STOCK_OPEN, gtk.RESPONSE_ACCEPT,
             gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL))

        if chooser.run() == gtk.RESPONSE_ACCEPT:
            self.open_ok_func(chooser.get_filename())
        chooser.destroy()


    def do_save_as(self, callback_action, widget):
        TestText.active_window_stack.push(self)
        self.text_view.get_buffer().save_as_buffer()
        TestText.active_window_stack.pop()

    def do_save(self, callback_action, widget):
        TestText.active_window_stack.push(self)
        buffer = self.text_view.get_buffer()
        if not buffer.filename:
            self.do_save_as(None, callback_action)
        else:
            buffer.save_buffer()
            TestText.active_window_stack.pop()

    def do_close(self, callback_action, widget):
        TestText.active_window_stack.push(self)
        self.check_close_view()
        TestText.active_window_stack.pop()

    def do_exit(self, callback_action, widget):
        TestText.active_window_stack.push(self)
        for tmp in TestText.buffers:
            if not tmp.check_buffer_saved():
                return

        gtk.main_quit()
        TestText.active_window_stack.pop()
        import sys
        sys.exit()

    def do_insert_and_scroll(self, callback_action, widget):
        buffer = self.text_view.get_buffer()

        start, end = buffer.get_bounds()
        mark = buffer.create_mark(None, end, False)

        buffer.insert(end,
                      "Hello this is multiple lines of text\n"
                      "Line 1\n"  "Line 2\n"
                      "Line 3\n"  "Line 4\n"
                      "Line 5\n")

        self.text_view.scroll_to_mark(mark, 0, True, 0.0, 1.0)
        buffer.delete_mark(mark)

    def do_wrap_changed(self, callback_action, widget):
        self.text_view.set_wrap_mode(callback_action)

    def do_varwindow_changed(self, callback_action, widget):
        self.use_varwindow = not self.use_varwindow

    def do_socketserver_changed(self, callback_action, widget):
        self.use_socketserver = not self.use_socketserver

    def do_color_cycle_changed(self, callback_action, widget):
        self.text_view.get_buffer().set_colors(callback_action)

    def do_apply_tabs(self, callback_action, widget):
        buffer = self.text_view.get_buffer()
        bounds = buffer.get_selection_bounds()
        if bounds:
            start, end = bounds
            if callback_action:
                buffer.remove_tag(buffer.custom_tabs_tag, start, end)
            else:
                buffer.apply_tag(buffer.custom_tabs_tag, start, end)

    def do_apply_colors(self, callback_action, widget):
        buffer = self.text_view.get_buffer()
        bounds = buffer.get_selection_bounds()
        if bounds:
            start, end = bounds
            if not callback_action:
                for tag in buffer.color_tags:
                    buffer.remove_tag(tag, start, end)
            else:
                tmp = buffer.color_tags
                i = 0
                next = start.copy()
                while next.compare(end) < 0:
                    next.forward_chars(2)
                    if next.compare(end) >= 0:
                        next = end

                    buffer.apply_tag(tmp[i], start, next)
                    i += 1
                    if i >= len(tmp):
                        i = 0
                    start = next.copy()

    def do_remove_tags(self, callback_action, widget):
        buffer = self.text_view.get_buffer()
        bounds = buffer.get_selection_bounds()
        if bounds:
            start, end = bounds
            buffer.remove_all_tags(start, end)

    def dialog_response_callback(self, dialog, response_id):
        if (response_id != RESPONSE_FORWARD and
            response_id != RESPONSE_BACKWARD):
            dialog.destroy()
            return

        start, end = dialog.buffer.get_bounds()
        search_string = start.get_text(end)

        print "Searching for `%s'\n" % search_string

        buffer = self.text_view.get_buffer()
        if response_id == RESPONSE_FORWARD:
            buffer.search_forward(search_string, self)
        elif response_id == RESPONSE_BACKWARD:
            buffer.search_backward(search_string, self)

        dialog.destroy()

    def do_search(self, callback_action, widget):
        search_text = gtk.TextView()
        dialog = gtk.Dialog("Search", self,
                            gtk.DIALOG_DESTROY_WITH_PARENT,
                            ("Forward", RESPONSE_FORWARD,
                             "Backward", RESPONSE_BACKWARD,
                             gtk.STOCK_CANCEL, gtk.RESPONSE_NONE))
        dialog.vbox.pack_end(search_text, True, True, 0)
        dialog.buffer = search_text.get_buffer()
        dialog.connect("response", self.dialog_response_callback)

        search_text.show()
        search_text.grab_focus()
        dialog.show_all()

    def do_undo(self, callback_action, widget):
        buffer = self.text_view.get_buffer()
        if buffer.can_undo():
            buffer.undo()

    def do_redo(self, callback_action, widget):
        buffer = self.text_view.get_buffer()
        if buffer.can_redo():
            buffer.redo()

    def init_menus(self):
        text_view = self.text_view
        direction = text_view.get_direction()
        wrap_mode = text_view.get_wrap_mode()
        menu_item = None

        if direction == gtk.TEXT_DIR_LTR:
            menu_item = self.item_factory.get_widget("/Settings/Left-to-Right")
        elif direction == gtk.TEXT_DIR_RTL:
            menu_item = self.item_factory.get_widget("/Settings/Right-to-Left")

        if menu_item:
            menu_item.activate()

        if wrap_mode == gtk.WRAP_NONE:
            menu_item = self.item_factory.get_widget("/Settings/Wrap Off")
        elif wrap_mode == gtk.WRAP_WORD:
            menu_item = self.item_factory.get_widget("/Settings/Wrap Words")
        elif wrap_mode == gtk.WRAP_CHAR:
            menu_item = self.item_factory.get_widget("/Settings/Wrap Chars")

        if menu_item:
            menu_item.activate()

    def close_view(self):
        TestText.views.remove(self)
        buffer = self.text_view.get_buffer()
        # buffer.unref()
        buffer.disconnect(self.bhid)
        self.text_view.destroy()
        del self.text_view
        self.text_view = None
        self.destroy()
        del self
        if not TestText.views:
            gtk.main_quit()

    def check_close_view(self):
        buffer = self.text_view.get_buffer()
        if (buffer.refcount > 1 or
            buffer.check_buffer_saved()):
            self.close_view()

    def set_view_title(self):
        pretty_name = self.text_view.get_buffer().pretty_name()
        title = "Shoebot - " + pretty_name
        self.set_title(title)

    def cursor_set_callback(self, buffer, location, mark):

        # TODO: here should go the line syntax highlighter
        # 1. get buffer
        #      get modification state
        # 2. get line contents
        # 3. replace by pygmentised content
        #      revert to modification state
        pass

    def tab_stops_expose(self, widget, event):
        #print self, widget, event
        text_view = widget

        # See if this expose is on the tab stop window
        top_win = text_view.get_window(gtk.TEXT_WINDOW_TOP)
        bottom_win = text_view.get_window(gtk.TEXT_WINDOW_BOTTOM)

        if event.window == top_win:
            type = gtk.TEXT_WINDOW_TOP
            target = top_win
        elif event.window == bottom_win:
            type = gtk.TEXT_WINDOW_BOTTOM
            target = bottom_win
        else:
            return False

        first_x = event.area.x
        last_x = first_x + event.area.width

        first_x, y = text_view.window_to_buffer_coords(type, first_x, 0)
        last_x, y = text_view.window_to_buffer_coords(type, last_x, 0)

        buffer = text_view.get_buffer()
        insert = buffer.get_iter_at_mark(buffer.get_insert())
        attrs = gtk.TextAttributes()
        insert.get_attributes(attrs)

        tabslist = []
        in_pixels = False
        if attrs.tabs:
            tabslist = attrs.tabs.get_tabs()
            in_pixels = attrs.tabs.get_positions_in_pixels()

        for align, position in tabslist:
            if not in_pixels:
                position = pango.PIXELS(position)

            pos, y = text_view.buffer_to_window_coords(type, position, 0)
            target.draw_line(text_view.style.fg_gc[text_view.state],
                             pos, 0, pos, 15)

        return True

    def get_lines(self, first_y, last_y, buffer_coords, numbers):
        text_view = self.text_view
        # Get iter at first y
        iter, top = text_view.get_line_at_y(first_y)

        # For each iter, get its location and add it to the arrays.
        # Stop when we pass last_y
        count = 0
        size = 0

        while not iter.is_end():
            y, height = text_view.get_line_yrange(iter)
            buffer_coords.append(y)
            line_num = iter.get_line()
            numbers.append(line_num)
            count += 1
            if (y + height) >= last_y:
                break
            iter.forward_line()

        return count

    def run_script(self, callback_action, widget):
        from shoebot import gtkui

        # get the buffer contents
        buffer = self.text_view.get_buffer()
        start, end = buffer.get_bounds()
        codestring = buffer.get_text(start, end)
        try:
            sbot_window = gtkui.ShoebotWindow(codestring, self.use_socketserver, 7777, self.use_varwindow)
        except shoebot.ShoebotError, NameError:
            import traceback
            import sys

            errmsg = traceback.format_exc(limit=1)
            err = "Error in Shoebot script:\n %s" % (errmsg)
            dialog = gtk.MessageDialog(self, gtk.DIALOG_MODAL,
                                       gtk.MESSAGE_INFO,
                                       gtk.BUTTONS_OK, err);
            result = dialog.run()
            dialog.destroy()
            return False
        # TODO: have a try/except that shows an error window

class Stack(list):
    def __init__(self):
        list.__init__(self)

    def push(self, item):
        self.insert(-1, item)

    def pop(self):
        del self[0]

    def get(self):
        return self[0]

class TestText:
    untitled_serial = 1
    colormap = None
    active_window_stack = Stack()
    buffers = Stack()
    views = Stack()

    def __init__(self, filelist):
        view = View()
        self.active_window_stack.push(view)
        for fname in filelist:
            filename = os.path.abspath(fname)
            view.open_ok_func(filename)
        self.active_window_stack.pop()

    def main(self):
        gtk.main()
        return 0

if __name__ == "__main__":
    testtext = TestText(sys.argv[1:])
    testtext.main()
